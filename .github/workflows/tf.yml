name: TF Via PR Comments — Reusable Workflow

# This reusable workflow parses PR comments for TF commands to run them
# in parallel on the PR branch along with any environment variables passed:
# https://github.com/devsectop/tf-via-pr/#readme.

on:
  workflow_call:
    secrets:
      env_vars:
        description: Environment variables passed into this workflow.
        required: false
    outputs:
      COMMENT_SHA:
        value: ${{ jobs.pre.outputs.COMMENT_SHA }}
        description: "SHA of the PR comment that triggered the workflow."
      PARSED_COMMENT:
        value: ${{ jobs.pre.outputs.PARSED_COMMENT }}
        description: "JSON object of the parsed PR comment."
      PROMPT_MATRIX:
        value: ${{ jobs.run.outputs.PROMPT_MATRIX }}
        description: "Matrix strategy of the last successfully completed job."
      TF_PLAN_ID:
        value: ${{ jobs.run.outputs.TF_PLAN_ID }}
        description: "Unique identifier of the TF plan file, used for artifact upload/download and bot comment update."
      WORKING_DIRECTORY:
        value: ${{ jobs.run.outputs.WORKING_DIRECTORY }}
        description: "Working directory of the TF configuration, used in `-chdir` argument."

permissions:
  actions: read # Required for downloading artifacts.
  contents: read # Required for checking out repository.
  issues: read # Required for getting PR branch.
  pull-requests: write # Required for commenting on PR.
  statuses: write # Required for setting commit status.

jobs:
  pre:
    # Parse the PR comment to output TF commands to run on the PR branch.
    # Run if the PR comment starts with "-tf=" (standard command prefix)
    # of if the PR has a label starting with "tf:" (indicating this workflow
    # has already been run on the PR and may be run again).
    if: startsWith(github.event.comment.body, '-tf=') || contains(join(github.event.pull_request.labels.*.name), 'tf:')
    runs-on: ubuntu-latest
    outputs:
      COMMENT_SHA: ${{ steps.get_branch.outputs.result }}
      PARSED_COMMENT: ${{ steps.parse_comment.outputs.result }}

    steps:
      # For subsequent commits on the PR branch, automatically re-run the most
      # recently added "-tf=plan" comment instead of manually re-triggering.
      - name: Find comment
        id: find_comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          result-encoding: string
          retries: 3
          script: |
            const { data: list_comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              per_page: 100,
              repo: context.repo.repo,
            });
            const find_comment = list_comments
              .sort((a, b) => b.id - a.id)
              .find((comment) => /^-tf=plan/.test(comment.body));
            return find_comment?.body;

      # Split the PR comment on newlines and parse the lines as an array of objects
      # in the format [ {"key1": "value1"}, {"key1": "value1", "key2": "value2"} ].
      # E.g., [ {"tf": "apply", "chdir": "path/to/dir", "auto-approve": true} ]
      - name: Parse comment
        id: parse_comment
        if: github.event.issue.pull_request || steps.find_comment.outputs.result
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        env:
          comment: ${{ github.event.comment.body || steps.find_comment.outputs.result }}
        with:
          script: |
            return process.env.comment
              // Trim whitespace, split on newlines and remove empty lines from the array.
              .trim()
              .split("\n")
              .filter((line) => line.trim())
              .map((line) => {
                // For each line, split them on spaces outside of quotation marks.
                const args = line.match(/("[^"]+"|'[^']+'|[^'"\s]+)+/g);
                const obj = {};
                args.forEach((arg) => {
                  // Split the argument on the first equals sign to assign key-value pairs.
                  const [key, value] = arg.split(/=(.+)/);
                  // Remove the leading dash from the key and remove quotation
                  // marks outside of square brackets (for resource addresses)
                  // from the value if it exists, otherwise set to true (for flags).
                  obj[key.slice(1)] = value?.replace(/['"]+(?![^\[]*\])/g, "") || true;
                });
                return obj;
              });

      - name: Get comment branch
        id: get_branch
        if: github.event.issue.pull_request
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          result-encoding: string
          retries: 3
          script: |
            const { data: get_pull_request } = await github.rest.pulls.get({
              owner: context.repo.owner,
              pull_number: context.issue.number,
              repo: context.repo.repo,
            });
            return get_pull_request.head.sha;

      - name: Add commit status
        if: github.event.issue.pull_request
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          retries: 3
          script: |
            const add_pending_status = await github.rest.repos.createCommitStatus({
              context: "${{ github.workflow }}",
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: "${{ steps.get_branch.outputs.result }}",
              state: "pending",
              target_url: "${{ github.event.repository.html_url }}/actions/runs/${{ github.run_id }}",
            });

  run:
    # Run TF commands in parallel on the PR branch after populating any
    # environment variables passed into this workflow. E.g., for authentication.
    needs: [pre]
    runs-on: ubuntu-latest
    outputs:
      PROMPT_MATRIX: ${{ steps.environment_variables.outputs.PROMPT_MATRIX }}
      TF_PLAN_ID: ${{ steps.tf_variables.outputs.TF_PLAN_ID }}
      WORKING_DIRECTORY: ${{ steps.tf_variables.outputs.WORKING_DIRECTORY }}

    # Run each TF command to completion.
    strategy:
      fail-fast: false
      matrix:
        in: ${{ fromJSON(needs.pre.outputs.PARSED_COMMENT) }}

    env:
      TF_CLI_ARGS: -no-color
      TF_IN_AUTOMATION: true
      TF_INPUT: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
        with:
          ref: ${{ github.head_ref || format('refs/pull/{0}/merge', github.event.issue.number) }}

      # For each environment variable's key-value pair, mask the value from logs.
      # If the key is prefixed with "BASE64_", then decode the value from base64.
      # E.g., for passing in temporary/OIDC credentials output from a previous job.
      - name: Populate environment variables
        id: environment_variables
        env:
          env_vars: ${{ secrets.env_vars }}
          matrix: ${{ toJSON(matrix.in) }}
        run: |
          echo PROMPT_MATRIX=$matrix >> $GITHUB_OUTPUT
          if [ -z "$env_vars" ]; then
            exit 0
          else
            # Iterate over all key-value pairs passed into this workflow and
            # add them as environment variables for use in subsequent steps.
            # Keys prefixed with "BASE64_" will be decoded from base64 and the
            # prefix will be removed. E.g., "BASE64_KEY=value" becomes "KEY=value".
            # Keys prefixed with "TVP_" will not be masked from logs to avoid
            # masking non-sensitive configuration variables of this workflow.
            for i in $env_vars; do
              if [[ $i == BASE64_* ]]; then i=$(echo $i | sed 's/^BASE64_//g' | sed 's/=.*//g')=$(echo ${i#*=} | base64 -di | base64 -di); fi
              if [[ $i != TVP_* ]]; then echo ::add-mask::${i#*=}; fi
              printf '%s\n' $i >> $GITHUB_ENV
            done
          fi

      # If the PR doesn't have one already, add a colored PR label to indicate
      # which TF commands have attempted to run on the PR branch.
      # E.g., "tf:plan", "tf:apply", "tf:force-unlock", etc.
      - name: Add PR label
        if: (!contains(join(github.event.pull_request.labels.*.name), format('tf:{0}', matrix.in['tf'])))
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          retries: 3
          script: |
            const add_label = await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              labels: ["tf:${{ matrix.in['tf'] }}"],
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const update_label = await github.rest.issues.updateLabel({
              color: "${{ env.TVP_CLI_USES == 'tofu' && 'FFDA18' || '5C4EE5' }}",
              description: "Pull requests that ${{ matrix.in['tf'] }} TF code",
              name: "tf:${{ matrix.in['tf'] }}",
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

      # If TVP_APPLY_REQUIRE_APPROVAL is set to "true", then verify that the PR
      # review state is approved. If not, then exit the workflow with a failure.
      - name: Check PR approval
        if: matrix.in['tf'] == 'apply' && env.TVP_APPLY_REQUIRE_APPROVAL == 'true'
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          retries: 3
          script: |
            const { data: list_reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              pull_number: context.issue.number,
              repo: context.repo.repo,
            });
            if (list_reviews.at(-1)?.state !== "APPROVED") {
              core.setFailed("PR review approval is required when TVP_APPLY_REQUIRE_APPROVAL is set to true.");
            }

      - name: Setup Terraform
        if: env.TVP_CLI_USES == 'terraform' || env.TVP_CLI_USES == ''
        uses: hashicorp/setup-terraform@a1502cd9e758c50496cc9ac5308c4843bcd56d36 # v3.0.0
        with:
          cli_config_credentials_hostname: ${{ env.TVP_CLI_HOSTNAME }}
          cli_config_credentials_token: ${{ env.TVP_CLI_TOKEN }}
          terraform_version: 1.6.0-alpha3
          terraform_wrapper: true
        # terraform_version: ${{ env.TVP_CLI_VERSION || 'latest' }}

      - name: Setup OpenTofu
        if: env.TVP_CLI_USES == 'tofu'
        uses: opentofu/setup-opentofu@b06654f7ba51088e987c0a454d042360df3ebe86 # v1.0.1
        with:
          cli_config_credentials_hostname: ${{ env.TVP_CLI_HOSTNAME }}
          cli_config_credentials_token: ${{ env.TVP_CLI_TOKEN }}
          tofu_version: ${{ env.TVP_CLI_VERSION || 'latest' }}
          tofu_wrapper: true

      # For each possible TF command argument, process then pass them into
      # environment variables. E.g., "-chdir=path/to/dir", "-auto-approve", etc.
      - name: Populate TF variables
        id: tf_variables
        env:
          TVP__AUTO_APPROVE: ${{ matrix.in['auto-approve'] }}
          TVP__BACKEND_CONFIG: ${{ env.TVP_BACKEND_CONFIG_FROM_WORKSPACE && matrix.in['workspace'] || matrix.in['backend-config'] }}
          TVP__BACKEND: ${{ matrix.in['backend'] }}
          TVP__CHDIR: ${{ format('{0}{1}', env.TVP_CHDIR_PREFIX, matrix.in['chdir']) }}
          TVP__CLOUD: ${{ matrix.in['cloud'] }}
          TVP__COMPACT_WARNINGS: ${{ matrix.in['compact-warnings'] }}
          TVP__DESTROY: ${{ matrix.in['destroy'] }}
          TVP__FROM_MODULE: ${{ matrix.in['from-module'] }}
          TVP__GET: ${{ matrix.in['get'] }}
          TVP__IGNORE_REMOTE_VERSION: ${{ matrix.in['ignore-remote-version'] }}
          TVP__LOCK_TIMEOUT: ${{ matrix.in['lock-timeout'] }}
          TVP__LOCK: ${{ matrix.in['lock'] }}
          TVP__LOCKFILE: ${{ matrix.in['lockfile'] }}
          TVP__NO_TESTS: ${{ matrix.in['no-tests'] }}
          TVP__PARALLELISM: ${{ matrix.in['parallelism'] }}
          TVP__PLUGIN_DIR: ${{ matrix.in['plugin-dir'] }}
          TVP__REFRESH_ONLY: ${{ matrix.in['refresh-only'] }}
          TVP__REFRESH: ${{ matrix.in['refresh'] }}
          TVP__REPLACE: ${{ matrix.in['replace'] }}
          TVP__TARGET: ${{ matrix.in['target'] }}
          TVP__TEST_DIRECTORY: ${{ matrix.in['test-directory'] }}
          TVP__TF: ${{ matrix.in['tf'] }}
          TVP__UPGRADE: ${{ matrix.in['upgrade'] }}
          TVP__VAR_FILE: ${{ env.TVP_VAR_FILE_FROM_WORKSPACE && matrix.in['workspace'] || matrix.in['var-file'] }}
          TVP__WORKSPACE: ${{ matrix.in['workspace'] }}
        run: |
          # Iterate over all environment variables prefixed with "TVP__".
          env | grep TVP__ | while read -r line; do
            # Set the variable name from the string before the first equals sign.
            name=$(echo "$line" | cut -d= -f1)
            # Set the argument key from the variable after removing the "TVP__"
            # prefix, converting it to lowercase, and replacing underscores with dashes.
            # E.g., "TVP__CHDIR=path/to/dir" becomes "var-file".
            key=$(echo "$name" | sed 's/^TVP__//' | sed 's/_/-/g' | tr '[:upper:]' '[:lower:]')
            # Set the argument value from the variable after the first equals sign
            # and replacing spaces with escaped spaces to prevent splitting.
            # E.g., "TVP__VAR_FILE=path/to/dir name" becomes "path/to/dir\ name".
            value=$(echo "$line" | cut -d= -f2- | sed 's/ /\\ /g')

            # If the argument value is "true", then treat its key as a flag.
            # E.g., "TVP__AUTO_APPROVE=true" becomes "-auto-approve".
            if [ "$value" == "true" ]; then
              echo "$name=-$key" >> $GITHUB_ENV
            # If the argument value is non-empty, then pass it as-is.
            # E.g., "TVP__CHDIR=path/to/dir" becomes "-chdir=path/to/dir".
            elif [ -n "$value" ]; then
              # If it contains one or more commas, then split on commas and
              # pass each value as a separate argument with the same key.
              # E.g., "TVP__TARGET=resource.address1,resource.address2" becomes
              # "-target=resource.address1 -target=resource.address2".
              if [ "$value" == "${value/,/}" ]; then
                echo "$name=-$key=$value" >> $GITHUB_ENV
              else
                echo "$name=-$key=${value//,/ -${key}=}" >> $GITHUB_ENV
              fi
            fi
          done

          # Store the path to the TF plan file for artifact upload/download.
          echo "WORKING_DIRECTORY=$TVP__CHDIR" >> $GITHUB_ENV
          echo "WORKING_DIRECTORY=$TVP__CHDIR" >> $GITHUB_OUTPUT
          # Store a combination of the PR number and TF command arguments
          # for use as a unique identifier to reference the TF plan file.
          echo "TF_PLAN_ID=$(echo ${{ github.event.number || github.event.issue.number }}$TVP__BACKEND_CONFIG$TVP__CHDIR$TVP__VAR_FILE$TVP__WORKSPACE$TVP__DESTROY-tfplan | sed 's/[[:space:][:punct:]]/-/g')" >> $GITHUB_ENV
          echo "TF_PLAN_ID=$(echo ${{ github.event.number || github.event.issue.number }}$TVP__BACKEND_CONFIG$TVP__CHDIR$TVP__VAR_FILE$TVP__WORKSPACE$TVP__DESTROY-tfplan | sed 's/[[:space:][:punct:]]/-/g')" >> $GITHUB_OUTPUT
          # If "-backend-config" argument is present, then include any prefix and suffix.
          if [ -n "$TVP__BACKEND_CONFIG" ]; then echo "TVP__BACKEND_CONFIG=-backend-config=$TVP_BACKEND_CONFIG_PREFIX$TVP__BACKEND_CONFIG$TVP_BACKEND_CONFIG_SUFFIX" >> $GITHUB_ENV; fi
          # If "-var-file" argument is present, then include any prefix and suffix.
          if [ -n "$TVP__VAR_FILE" ]; then echo "TVP__VAR_FILE=-var-file=$TVP_VAR_FILE_PREFIX$TVP__VAR_FILE$TVP_VAR_FILE_SUFFIX" >> $GITHUB_ENV; fi
          # If "-tf=apply" is run without "-auto-approve", then ignore
          # the "-var-file" argument so the that the TF plan file is used.
          if [ -z "$TVP__AUTO_APPROVE" ] && [ "$TVP__TF" == "apply" ]; then echo "TVP__VAR_FILE=" >> $GITHUB_ENV; fi
          # If "-auto-approve" is not supplied, then set it to read from "tfplan".
          if [ -z "$TVP__AUTO_APPROVE" ]; then echo "TVP__AUTO_APPROVE=tfplan" >> $GITHUB_ENV; fi
          # If $TVP_CLI_USES is not set, then set it to "terraform".
          if [ -z "$TVP_CLI_USES" ]; then echo "TVP_CLI_USES=terraform" >> $GITHUB_ENV; fi

      - name: TF init
        id: tf_init
        run: $TVP_CLI_USES $TVP__CHDIR init $TVP__BACKEND $TVP__BACKEND_CONFIG $TVP__CLOUD $TVP__FROM_MODULE $TVP__GET $TVP__IGNORE_REMOTE_VERSION $TVP__LOCK $TVP__LOCK_TIMEOUT $TVP__LOCKFILE $TVP__PLUGIN_DIR $TVP__UPGRADE

      - name: TF validate
        if: env.TVP_VALIDATE_ENABLE == 'true' || env.TVP_VALIDATE_ENABLE == ''
        id: tf_validate
        run: $TVP_CLI_USES $TVP__CHDIR validate $TVP__NO_TESTS $TVP__TEST_DIRECTORY

      - name: TF fmt
        id: tf_fmt
        if: env.TVP_FMT_ENABLE == 'true' || env.TVP_FMT_ENABLE == ''
        run: $TVP_CLI_USES $TVP__CHDIR fmt -check -diff -recursive
        continue-on-error: true

      # If a TF workspace is specified, then select it if it exists,
      # otherwise create a new one.
      - name: TF workspace
        id: tf_workspace
        if: matrix.in['workspace'] != ''
        run: $TVP_CLI_USES $TVP__CHDIR workspace select "${{ matrix.in['workspace'] }}" || $TVP_CLI_USES $TVP__CHDIR workspace new "${{ matrix.in['workspace'] }}"

      - name: TF plan
        id: tf_plan
        if: matrix.in['tf'] == 'plan'
        run: $TVP_CLI_USES $TVP__CHDIR plan -out=tfplan $TVP__COMPACT_WARNINGS $TVP__DESTROY $TVP__LOCK $TVP__LOCK_TIMEOUT $TVP__PARALLELISM $TVP__REFRESH $TVP__REFRESH_ONLY $TVP__REPLACE $TVP__TARGET $TVP__VAR_FILE

      # If "-tf=plan" is successful, then upload the TF plan file
      # as a zipped repository artifact with a unique identifier for later download.
      - name: Upload TF plan
        if: matrix.in['tf'] == 'plan' && steps.tf_plan.outputs.exitcode == 0
        uses: actions/upload-artifact@a8a3f3ad30e3422c9c7b888a15615d19a852ae32 # v3.1.3
        with:
          name: ${{ env.TF_PLAN_ID }}
          path: ${{ env.WORKING_DIRECTORY }}/tfplan

      # If "-tf=apply" is run without "-auto-approve", then get the download
      # link for the most recently uploaded TF plan file artifact which
      # matches the unique identifier.
      - name: Download TF plan
        id: artifact_url
        if: matrix.in['tf'] == 'apply' && matrix.in['auto-approve'] == ''
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          result-encoding: string
          retries: 3
          script: |
            const { data: list_artifacts } = await github.rest.actions.listArtifactsForRepo({
              name: "${{ env.TF_PLAN_ID }}",
              owner: context.repo.owner,
              per_page: 100,
              repo: context.repo.repo,
            });
            const download_artifact = await github.rest.actions.downloadArtifact({
              archive_format: "zip",
              artifact_id: list_artifacts.artifacts[0].id,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            return download_artifact.url;

      # Download the zipped repository artifact then unzip/inflate the TF
      # plan file to the specified working directory.
      - name: Unzip TF plan
        if: matrix.in['tf'] == 'apply' && matrix.in['auto-approve'] == ''
        run: wget -O "${{ env.TF_PLAN_ID }}" "${{ steps.artifact_url.outputs.result }}" && unzip "${{ env.TF_PLAN_ID }}" -d "${{ env.WORKING_DIRECTORY }}"

      - name: TF apply
        id: tf_apply
        if: matrix.in['tf'] == 'apply'
        run: $TVP_CLI_USES $TVP__CHDIR apply $TVP__COMPACT_WARNINGS $TVP__DESTROY $TVP__LOCK $TVP__LOCK_TIMEOUT $TVP__PARALLELISM $TVP__REFRESH $TVP__REFRESH_ONLY $TVP__REPLACE $TVP__TARGET $TVP__VAR_FILE $TVP__AUTO_APPROVE

      - name: TF force-unlock
        id: tf_force_unlock
        if: matrix.in['tf'] == 'force-unlock'
        run: $TVP_CLI_USES $TVP__CHDIR force-unlock -force "${{ matrix.in['lock-id'] }}"

      # Reduce TF result verbosity for ease of legibility.
      - name: Filter TF result
        id: tf_result
        if: ${{ (success() || failure()) && (steps.tf_apply.outputs.stderr || steps.tf_apply.outputs.stdout || steps.tf_plan.outputs.stderr || steps.tf_plan.outputs.stdout || steps.tf_force_unlock.outputs.stderr || steps.tf_force_unlock.outputs.stdout || steps.tf_workspace.outputs.stderr || steps.tf_fmt.outputs.stdout || steps.tf_validate.outputs.stderr || steps.tf_init.outputs.stderr) }}
        run: |
          # Reduce the comment's verbosity by removing lines related to fetching
          # the state of resources. Due to GitHub's comment size limitation of
          # 64KB or a count of 65536, truncate above the last 64800 characters
          # to capture the final change summary of the TF command while leaving
          # room for the comment's header and footer.
          TF_RESULT_RAW=$(cat <<'EOTF'
          ${{ steps.tf_apply.outputs.stderr || steps.tf_apply.outputs.stdout || steps.tf_plan.outputs.stderr || steps.tf_plan.outputs.stdout || steps.tf_force_unlock.outputs.stderr || steps.tf_force_unlock.outputs.stdout || steps.tf_workspace.outputs.stderr || steps.tf_validate.outputs.stderr || steps.tf_init.outputs.stderr }}
          EOTF
          )
          echo 'TF_RESULT<<EOTF' >> $GITHUB_OUTPUT
          echo "$TF_RESULT_RAW" |
            grep -vE ': Creating...|: Creation complete after|: Destroying...|: Destruction complete after|: Modifications complete after|: Modifying...|: Provisioning with|: Read complete after|: Reading...|: Refreshing state...|: Still creating...|: Still destroying...|: Still modifying...|: Still reading...|. This may take a few moments...' |
            tail -c 64800 >> $GITHUB_OUTPUT
          echo 'EOTF' >> $GITHUB_OUTPUT

          # As above, truncate after the first 7200 characters to capture the
          # diff summary of the TF fmt.
          TF_FMT_RAW=$(cat <<'EOTF'
          ${{ steps.tf_fmt.outputs.stdout }}
          EOTF
          )
          echo 'TF_FMT<<EOTF' >> $GITHUB_OUTPUT
          echo "$TF_FMT_RAW" | head -c 7200 >> $GITHUB_OUTPUT
          echo 'EOTF' >> $GITHUB_OUTPUT

      # If any TF commands are run, successfully or not, log the most
      # recent result in a PR comment for review and debugging purposes.
      - name: Comment TF result
        if: ${{ (success() || failure()) && steps.tf_result.outcome == 'success' }}
        env:
          PROMPT_MATRIX: ${{ steps.environment_variables.outputs.PROMPT_MATRIX }}
          TF_RESULT: ${{ steps.tf_result.outputs.TF_RESULT }}
          TF_FMT: ${{ steps.tf_result.outputs.TF_FMT }}
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          retries: 3
          script: |
            // Display the most recent TF change summary as the header/title of
            // the collapsible content.
            const comment_summary = process.env.TF_RESULT
              .split("\n")
              .reverse()
              .find((line) => /^(Apply|Plan|Error|No changes)/.test(line)) ||
            "View TF result…";

            // Display the truncated TF fmt enclosed in diff syntax, if present.
            const comment_fmt = process.env.TF_FMT
              ? `<details><summary>Diff of format changes.</summary>

              \`\`\`diff
              ${process.env.TF_FMT}
              \`\`\`
              </details>`
              : "";

            // Display the TF command authorship before the TF result as the
            // body of the collapsible content. Include the TFPLAN name in a
            // hidden footer as a unique identifier for comment updates.
            const comment_body = `
            \`${process.env.PROMPT_MATRIX}\`
            ${comment_fmt}
            <details><summary>${comment_summary}</br>

            ###### ${{ github.workflow }} by @${{ github.actor }} via [${{ github.event_name }}](${{ github.event.repository.html_url }}/actions/runs/${{ github.run_id }}) at ${{ github.event.pull_request.updated_at || github.event.comment.updated_at }}.</summary>

            \`\`\`hcl
            ${process.env.TF_RESULT}
            \`\`\`
            </details>
            <!-- ${process.env.TF_PLAN_ID} -->`;

            // Check if the bot has commented on the PR using the TFPLAN identifier.
            const { data: list_comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              per_page: 100,
              repo: context.repo.repo,
            });
            const bot_comment = list_comments.find((comment) => {
              return (
                comment.user.type === "Bot" &&
                comment.body.includes(`<!-- ${process.env.TF_PLAN_ID} -->`)
              );
            });

            // If a bot comment exists with a matching TFPLAN identifier, then update
            // the comment, otherwise create a new comment. This prevents the bot
            // from creating a new comment on every run of this workflow.
            if (bot_comment) {
              await github.rest.issues.updateComment({
                body: comment_body,
                comment_id: bot_comment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
            } else {
              await github.rest.issues.createComment({
                body: comment_body,
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
            }

      - name: Update commit status
        if: ${{ (success() || failure()) && github.event.issue.pull_request }}
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410 # v6.4.1
        with:
          retries: 3
          script: |
            const add_pending_status = await github.rest.repos.createCommitStatus({
              context: "${{ github.workflow }}",
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: "${{ needs.pre.outputs.COMMENT_SHA }}",
              state: "${{ job.status }}",
              target_url: "${{ github.event.repository.html_url }}/actions/runs/${{ github.run_id }}",
            });
