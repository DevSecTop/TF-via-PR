name: Terraform

on:
  # For terraform plan
  pull_request:
    types: [synchronize, reopened, labeled, unlabeled]

  # For terraform apply
  push:
    branches: [main]

  # Fallback on manual trigger
  workflow_dispatch:

# For GITHUB_TOKEN to amend pull request comments
permissions:
  contents: read
  pull-requests: write

# To run a single job at a time along with a fallback value
concurrency:
  cancel-in-progress: true
  group: ${{ github.workflow }}-${{ github.head_ref }} || ${{ github.run_id }}

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  # Get the list of environments on which to run terraform plan/apply
  environments:
    runs-on: ubuntu-latest

    # Set the list of environments as output for subsequent jobs
    outputs:
      matrix: ${{ steps.set_matrix.outputs.result }}

    steps:
      # Print github context for debugging
      - name: Github context
        run: echo '${{ toJSON(github) }}'

      # Query GitHub API to return a filtered list of labels
      - name: Set matrix
        uses: actions/github-script@v6
        id: set_matrix
        with:
          script: |
            let result;

            // If issue number is present (on pull_request event) then get the labels from the issue
            if (context.issue.number) {
              result = (
                await github.rest.issues.listLabelsOnIssue({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                })
              ).data;

            // Otherwise (on push event) get the labels from the commit
            } else {
              result = (
                await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  commit_sha: context.sha,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                })
              ).data[0].labels;
            }

            // Return filtered list of labels with 'tf:' prefix removed
            return result
              .filter((label) => label.name.startsWith('tf:'))
              .map((label) => label.name.replace('tf:', ''))
              .map((label) => (label.match('--') ? label : label + '--default'));

  test:
    runs-on: ubuntu-latest
    needs: [environments]
    strategy:
      fail-fast: false
      matrix:
        path: ${{ fromJSON(needs.environments.outputs.matrix) }}
    steps:
      - name: test
        run: |
          echo ${{ matrix.path }}
          echo ${{ matrix.path/--* }}
          echo ${{ matrix.path /*-- }}

  # plan:
  #   # Only run on pull_request event if one or more environments are present
  #   if: ${{ github.event_name == 'pull_request' && needs.environments.outputs.matrix != '' && toJson(fromJson(needs.environments.outputs.matrix)) != '[]' }}
  #   runs-on: ubuntu-latest
  #   needs: [environments]

  #   # Run for each environment and continue to release state lock on fail
  #   strategy:
  #     fail-fast: false
  #     matrix:
  #       path: ${{ fromJSON(needs.environments.outputs.matrix) }}

  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     # Check terraform configuration is valid
  #     - name: Terraform validate
  #       uses: dflook/terraform-validate@v1
  #       with:
  #         path: environments/${{ matrix.path/--* }}
  #         backend_config_file: environments/backend.tfvars
  #         backend_config: key=environments/${{ matrix.path/--* }}/terraform.tfstate
  #         # workspace: ${{ matrix.path /*-- }}

  #     # Run terraform plan with environment label
  #     - name: Terraform plan
  #       uses: dflook/terraform-plan@v1
  #       with:
  #         label: ${{ matrix.path/--* }}
  #         workspace: ${{ matrix.path /*-- }}
  #         backend_config_file: environments/backend.tfvars
  #         backend_config: key=environments/${{ matrix.path/--* }}/terraform.tfstate
  #         # path: environments/${{ matrix.path/--* }}

  # apply:
  #   # Only run on push event if one or more environments are present
  #   if: ${{ github.event_name == 'push' && needs.environments.outputs.matrix != '' && toJson(fromJson(needs.environments.outputs.matrix)) != '[]' }}
  #   runs-on: ubuntu-latest
  #   needs: [environments]

  #   # Run for each environment and continue to release state lock on fail
  #   strategy:
  #     fail-fast: false
  #     matrix:
  #       path: ${{ fromJSON(needs.environments.outputs.matrix) }}

  #   # Set GitHub environment to track deployment status
  #   environment:
  #     name: ${{ matrix.path }}
  #     url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     # Run terraform apply with environment label
  #     - name: Terraform apply
  #       uses: dflook/terraform-apply@v1
  #       with:
  #         label: ${{ matrix.path }}
  #         path: environments/${{ matrix.path }}
  #         backend_config_file: environments/backend.tfvars
  #         backend_config: key=environments/${{ matrix.path }}/terraform.tfstate
